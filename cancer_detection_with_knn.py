# -*- coding: utf-8 -*-
"""Cancer Detection with KNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/137yL-QwAeKJUF39NzrQp2psW0gnj0RAK
"""

#importing libraries and loading data from sk learn

import numpy as np
import pandas as pd
from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split


cancer = load_breast_cancer()


print(cancer['feature_names'])

cancer.target_names

"""# **Preparing Dataframe**"""

columns =['mean radius', 'mean texture', 'mean perimeter', 'mean area',
'mean smoothness', 'mean compactness', 'mean concavity',
'mean concave points', 'mean symmetry', 'mean fractal dimension',
'radius error', 'texture error', 'perimeter error', 'area error',
'smoothness error', 'compactness error', 'concavity error',
'concave points error', 'symmetry error', 'fractal dimension error',
'worst radius', 'worst texture', 'worst perimeter', 'worst area',
'worst smoothness', 'worst compactness', 'worst concavity',
'worst concave points', 'worst symmetry', 'worst fractal dimension','target']



index =pd.RangeIndex(start=0, stop=569, step=1)


data=pd.DataFrame(np.c_[cancer['data'], cancer['target']],index,columns,dtype=object)
data.columns

"""# **Data Exploration**"""

data.info()

data.describe()

##Frequency of each class class
data['target'].value_counts() # 0 = malignant, 1= benign

"""# **Counting frequency of each target class**"""

mal=0
ben=0


for i in range(0,568):
        if data['target'][i] == 0:
            mal=mal+1
        else :
            ben=ben+1
    
    
print('0:',mal , '1:',ben) 
targetdata=np.array([mal,ben])

target=pd.Series(targetdata,index = ['malignant', 'benign'],dtype=int)

target

"""# **Splitting the feaures and Target**"""

X=data.iloc[:,:30]
y=data.iloc[:,30:]

"""# **Splitting Train and Test set**"""

print(X.shape,y.shape)

#as.type is used because datatype are seen to be float float but actually they are object type so to make them float we use astype()
X=X.astype('float64')
y=y.astype('float64')
X_train, X_test, y_train,  y_test=train_test_split(X,y,random_state=0)
   
y_train

"""# **Correlation between features**"""

corr_matrix=X.corr()
print(corr_matrix)

"""# **Training Knn classifier**"""

from sklearn.neighbors import KNeighborsClassifier
neigh = KNeighborsClassifier(n_neighbors=30)

y_train=np.array(y_train,dtype=np.int64)
y_train_new=np.ravel(y_train,order='C')

y_test=np.array(y_test,dtype=np.int64)
y_test_new=np.ravel(y_test,order='C')

neigh.fit(X_train, y_train_new)

"""# **Evaluation With cross validation**"""

from sklearn.model_selection import cross_val_score

cross_val_score(neigh,X_train, y_train_new,cv=5,scoring='accuracy')

"""# **Confusion Matrix**"""

from sklearn.model_selection import cross_val_predict
y_train_pred=cross_val_predict(neigh,X_train, y_train_new,cv=5)


from sklearn.metrics import confusion_matrix

print(confusion_matrix(y_train_new,y_train_pred))

from sklearn.metrics import plot_confusion_matrix
disp = plot_confusion_matrix(neigh, X_train, y_train_new,
                                 display_labels= ['class 0', 'class 1'],
                                 cmap=plt.cm.Blues)

print(disp.confusion_matrix)

"""# **Classification report (precision    recall  f1-score)**"""

from sklearn.metrics import classification_report
target_names = ['class 0', 'class 1']
print(classification_report(y_train_new,y_train_pred, target_names=target_names))

"""# Precision recall curve"""

import matplotlib.pyplot as plt

from sklearn.metrics import precision_recall_curve

precision, recall, thresholds = precision_recall_curve(y_train_new,y_train_pred)

plt.plot(precision,recall)
plt.xlabel('precision')
plt.ylabel('recall')

plt.show()
print(precision)
print(recall)
print(thresholds)

from sklearn.metrics import precision_score
from sklearn.metrics import recall_score

precision=precision_score(y_train_new,y_train_pred)
recall=recall_score(y_train_new,y_train_pred)

print("precision",precision)
print('recall',recall)

"""# **Making Prediction and computing Precision and recall**"""

y_test_pred=cross_val_predict(neigh,X_test, y_test_new,cv=5)


precision=precision_score(y_test_new,y_test_pred)
recall=recall_score(y_test_new,y_test_pred)

print("precision",precision)
print('recall',recall)